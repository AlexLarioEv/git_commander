# Оглавление

- [Введение](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#введение)
- [Основные команды Git](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#основные-команды-git)
  - [git init](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-init)
  - [git clone](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-clone)
  - [git add](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-add)
  - [git commit](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-commit)
  - [git push](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-push)
  - [git diff](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-diff)
  - [git apply](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-apply)
  - [git restore](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-restore)
  - [git reset](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-reset)
  - [git-rm](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-rm)
- [Команды по работе с ветками](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#команды-по-работе-с-ветками)
  - [git branch](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-branch)
  - [git checkout](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-checkout)
  - [git stash](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-stash)
- [Совместное использование и обновление проектов](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#совместное-использование-и-обновление-проектов)
  - [git fetch](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-fetch)
  - [git pull](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-pull)
- [Прочии команды для Git](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#прочии-команды-для-git)
  - [git cherry-pick](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-cherry-pick)
  - [git reflog](https://github.com/AlexLarioEv/git_commander?tab=readme-ov-file#git-reflog)

# Введение

Данная Wiki статья познокомит вас с git командами и поможет разобраться как использовать эти команды в проекте. Каждый пункт статьи следует следующиму шаблону: заголовок (git комманда), краткое описание этой команды, для чего она нужна и пример как она применяется.

>Вообще не обязательно читать всю статью. Эта статья изначально задумывалась как большая шпаргалка, в которую можно посмотреть во время разработки.


# Основные команды Git

## git init 

git init - это команда Git, которая инициализирует новый репозиторий Git в пустой директории или преобразует существующий проект в репозиторий Git.

Команда git init создает скрытую папку .git, которая содержит все необходимые файлы и директории для работы с Git. Эта папка содержит служебные файлы, такие как индекс (index), лог коммитов (logs), конфигурационные файлы (config) и т.д. Она также используется для хранения всех версий файлов и истории изменений.

Пример использования команды git init:

```
cd /path/to/project
git init
```
Эта команда создаст новый репозиторий Git в текущей директории.

Команда git init также поддерживает ряд флагов, которые позволяют управлять процессом инициализации репозитория. Например, флаг --bare создает "голый" репозиторий, который не имеет рабочей директории и используется только для обмена данными между репозиториями. Флаг --template=<template-directory> позволяет указать пользовательский шаблон репозитория для инициализации. Флаг --separate-git-dir=<gitdir> позволяет создавать репозиторий Git в другой директории, отличной от рабочей директории проекта.

## git clone

git clone - это команда Git, которая используется для создания локальной копии удаленного репозитория Git.

Команда git clone создает полную копию удаленного репозитория в локальной директории. После выполнения команды git clone, Git загружает все файлы, коммиты, историю изменений и другие данные из удаленного репозитория в локальный репозиторий, где пользователь может работать с ними локально.

Пример использования команды git clone:
```
git clone https://github.com/user/repo.git
```
Эта команда создает локальную копию удаленного репозитория по указанному адресу https://github.com/user/repo.git.

При клонировании удаленного репозитория Git автоматически создает новую директорию с именем репозитория, загружает все файлы из удаленного репозитория и создает локальную копию в этой директории. После этого Git настраивает локальный репозиторий так, чтобы он был связан с удаленным репозиторием и мог получать и отправлять изменения.

Команда git clone также поддерживает ряд флагов, которые позволяют настроить процесс клонирования, например, флаг --depth для клонирования репозитория только до определенного количества коммитов, чтобы уменьшить объем загружаемых данных.

## git add
Команда git add используется для добавления изменений в индекс Git перед коммитом. Индекс (также известный как "область подготовки" или "stage") - это промежуточное хранилище для изменений перед тем, как они будут закоммичены.
```
git add <file>
```
где <file> - это файл или директория, которые вы хотите добавить в индекс.

Если вы хотите добавить все измененные файлы и директории в текущей директории в индекс, вы можете выполнить команду:

```
git add .
```
Вы также можете использовать различные опции для настройки поведения команды git add, например, для добавления только изменений в отслеживаемых файлах:

```
git add -u
```
или для добавления изменений вместе с удаленными файлами:
```
git add -A
```
## git commit 

Команда git commit используется для фиксации изменений в репозитории Git. При выполнении команды git commit, изменения, находящиеся в индексе, сохраняются в новом коммите в локальном репозитории Git.
```
git commit -m "Описание изменений"
```
где -m означает "message" (сообщение) и "Описание изменений" - это краткое описание изменений, которые вы внесли в этот коммит.

После выполнения команды git commit, изменения будут сохранены в локальном репозитории Git. Обратите внимание, что коммиты являются неизменяемыми, поэтому вам следует описывать изменения в сообщении коммита максимально точно и подробно.

## git push

Команда git push используется для отправки изменений, фиксированных в локальном репозитории Git, в удаленный репозиторий Git. При выполнении команды git push, локальные коммиты отправляются в соответствующую ветку удаленного репозитория.

```
git push <remote> <branch>

```
где <remote> - это название удаленного репозитория, а <branch> - это название ветки, которую вы хотите отправить.

После выполнения команды git push, изменения будут отправлены в удаленный репозиторий, и они будут доступны для других пользователей, которые работают с этим репозиторием.

Команда git push имеет несколько дополнительных флагов, которые можно использовать для настройки процесса отправки изменений в удаленный репозиторий. Ниже приведены некоторые наиболее полезные флаги для команды git push:

1. -u или --set-upstream: эта опция связывает локальную ветку с удаленной веткой и настраивает ее как "основную". Таким образом, в будущем, когда вы выполните git push без указания имени удаленного репозитория и ветки, Git будет автоматически отправлять изменения в эту ветку. Например, git push -u origin main.

2. -f или --force: этот флаг используется для принудительной отправки изменений в удаленный репозиторий, даже если это может привести к потере данных или конфликтам с другими коммитами. Этот флаг следует использовать с осторожностью, так как он может повредить работу других разработчиков, работающих с этим репозиторием. Например, git push -f origin main.

3. --tags: этот флаг отправляет теги (метки) вместе с изменениями в удаленный репозиторий. Например, git push --tags origin.

4. --dry-run: этот флаг используется для проверки, какие изменения будут отправлены в удаленный репозиторий, без фактической отправки. Это может быть полезно для проверки, какие изменения будут отправлены, прежде чем отправлять их на удаленный репозиторий. Например, git push --dry-run origin main.

>Обратите внимание, что использование флагов --force и --dry-run может повлиять на работу других разработчиков, работающих с тем же удаленным репозиторием, поэтому их следует использовать с осторожностью

## git diff

git diff - это команда Git, которая показывает различия между двумя состояниями репозитория. Это могут быть изменения между рабочей директорией и индексом (staging area), между индексом и последним коммитом, или между любыми двумя коммитами в истории репозитория.

Команда git diff имеет несколько форматов использования, наиболее распространенные из них:

1. git diff: показывает различия между рабочей директорией и индексом (staging area).

2. git diff --staged: показывает различия между индексом и последним коммитом.

3. git diff <commit1> <commit2>: показывает различия между двумя коммитами в истории репозитория.

4. git diff <branch1> <branch2>: показывает различия между двумя ветками репозитория.

Команда git diff может также использовать различные опции для настройки вывода. Например, опция --color-words показывает различия не на уровне строк, а на уровне слов, что может быть полезно при работе с большими файлами.

## git apply

git apply - это команда Git, которая применяет патчи (diff файлы), созданные с помощью команды git diff или другими утилитами. Она часто используется, когда необходимо применить изменения, которые были отправлены вам в виде патчей, но которые не были применены в вашу локальную копию репозитория.

Кроме того, команда git apply имеет ряд опций, позволяющих настроить процесс применения патчей. Например, опция --check позволяет проверить, применится ли патч, не применяя его на самом деле, а опция --reject позволяет сохранить отклоненные изменения в файле .rej

## git restore

git restore - это команда Git, которая позволяет восстанавливать файлы и/или изменения в файлах до их последнего коммита. Она была введена в версии Git 2.23 в качестве более простой и интуитивно понятной альтернативы командам git reset и git checkout.

Некоторые примеры использования команды git restore:

1. Восстановление изменений в файле до последнего коммита:
```
git restore <file>
```
2. Восстановление всех изменений в рабочей директории до последнего коммита:
```
git restore .
```
3. Отмена изменений в определенном файле:
```
git restore --staged <file>
```
4. Отмена изменений во всех файлах, добавленных в индекс:
```
git restore --staged .
```
5. Восстановление файла до конкретного коммита:
```
git restore --source=<commit> <file>
```
>Обратите внимание, что команда git restore по умолчанию не восстанавливает изменения, которые были удалены с помощью git rm. Для восстановления таких изменений необходимо использовать команду git reset или git checkout.

## git reset

git reset - это команда Git, которая позволяет отменить изменения в коммитах и переместить указатель ветки на другой коммит. Она может использоваться для отмены коммитов, отмены изменений в рабочей директории и/или индексе.

екоторые примеры использования команды git reset:

1. Отмена последнего коммита, но сохранение его изменений в рабочей директории и индексе:

```
git reset HEAD~1
```
2. Отмена последнего коммита и удаление его изменений в рабочей директории, но сохранение их в индексе:
```
git reset --soft HEAD~1
```
3. Отмена последнего коммита и удаление его изменений в рабочей директории и индексе:
```
git reset --hard HEAD~1
```
4. Отмена изменений в индексе, но сохранение их в рабочей директории:
```
git reset <file>
```
5. Отмена всех изменений в индексе:
```
git reset
```
>Обратите внимание, что команда git reset может быть опасной, так как она изменяет историю коммитов. Поэтому, перед ее использованием, рекомендуется убедиться в том, что вы знаете, что делаете.

## git-rm

git rm - это команда Git, которая удаляет файлы из рабочей директории и индекса Git. При этом, если файлы были добавлены в предыдущий коммит, то git rm также удаляет их из истории коммитов.

Некоторые примеры использования команды git rm:

1. Удаление файла/файлов из рабочей директории и индекса Git:
```
git rm <file> или git rm <file1> <file2> <file3>
```
2. Удаление файла из рабочей директории, индекса Git и истории коммитов:
```
git rm --cached <file>
```
>Обратите внимание, что git rm удаляет файлы навсегда из Git, поэтому перед ее использованием рекомендуется >убедиться в том, что вы действительно хотите удалить файлы.

# Команды по работе с ветками

## git branch 
git branch - это команда Git, которая используется для работы с ветками репозитория. Она позволяет просмотреть список существующих веток, создать новую ветку и удалить ветку.

Некоторые примеры использования команды git branch:

1. Просмотр списка существующих веток:

```
git branch
```
2. Отображает список всех веток, включая удаленные.
```
git branch -a
```
3. Создание новой ветки new_branch:
```
git branch new_branch
```
4. Удаление ветки old_branch:

```
git branch -d old_branch
```
5. Принудительное удаление ветки old_branch, даже если ее изменения еще не были слиты с текущей веткой:
```
git branch -D old_branch
```

## git checkout

git checkout - это команда Git, которая используется для переключения между ветками, создания новых веток и восстановления файлов из индекса или предыдущих коммитов.

Некоторые примеры использования команды git checkout:

1. Переключение на существующую ветку feature_branch:
```
git checkout feature_branch
```
2. Создание новой ветки new_branch и переключение на нее:

```
git checkout -b new_branch
```
3. Восстановление файла file.txt из индекса:
```
git checkout -- file.txt
```
4. Восстановление файла file.txt из коммита с хэшем 123abc:
>хэш коммита - это уникальный идентификатор, присвоенный каждому коммиту в >репозитории Git.
```
git checkout 123abc -- file.txt
```
5. Переключение на предыдущую ветку:
```
git checkout -
```
6. Переключение на определенный коммит
```
git checkout <commit_hash>
```
## git stash

git stash - это команда Git, которая позволяет временно сохранить изменения в вашей рабочей директории и индексе (staged changes), чтобы вы могли переключиться на другую ветку или откатиться к предыдущей версии без сохранения изменений. Сохраненные изменения могут быть восстановлены позднее, когда вы снова вернетесь к этому коду.

Когда вы выполняете git stash, Git сохраняет изменения на стеке stash. Вы можете сохранять несколько стэшей, каждый из которых будет содержать свой набор изменений.

Вот несколько часто используемых флагов команды git stash:

1. Cохраняет изменения на стек stash и добавляет сообщение к этому stash, чтобы вы могли легче отслеживать, что было сохранено. Если сообщение не указано, Git попросит вас ввести его.
```
git stash save "message"
```
2. Отображает список сохраненных stash-ей.
```
git stash list
```
3. Применяет последний stash из стека stash, не удаляя его из стека. Если вы хотите применить более ранний stash, вам нужно указать его идентификатор.
```
git stash apply
```
4. Применяет последний stash и удаляет его из стека.
```
git stash pop
```
5. Удаляет stash из стека.
```
 git stash drop
```
# Совместное использование и обновление проектов

## git fetch 

git fetch - это команда Git, которая извлекает изменения из удаленного репозитория и сохраняет их в локальном репозитории, без слияния их с текущей веткой. Она полезна, когда вы хотите просмотреть изменения, которые были внесены в удаленный репозиторий, не объединяя их с вашей рабочей веткой.

Когда вы выполняете git fetch, Git получает изменения, которые были внесены в удаленный репозиторий с момента вашего последнего извлечения, и сохраняет их в локальной ветке, связанной с удаленным репозиторием. Эта локальная ветка называется "remote-tracking branch". Она содержит локальную копию удаленной ветки и помогает отслеживать изменения в удаленном репозитории.

Вот несколько часто используемых флагов команды git fetch:

1. Извлекает изменения из удаленного репозитория и сохраняет их в локальном репозитории, но не объединяет их с текущей веткой.
```
git fetch
```
2. Извлекает изменения из указанного удаленного репозитория и сохраняет их в локальном репозитории.
```
git fetch <remote>
```
## git pull

git pull - это команда Git, которая извлекает изменения из удаленного репозитория и объединяет их с текущей веткой. Эта команда объединяет изменения из удаленного репозитория и создает новый коммит в локальной ветке.

Когда вы выполняете git pull, Git извлекает изменения из удаленного репозитория, сохраняет их в локальной ветке и затем пытается объединить их с текущей веткой. Если есть конфликты, Git сообщит об этом, и вы должны будете разрешить конфликты вручную.

Вот несколько часто используемых флагов команды git pull:

1. Извлекает изменения из удаленного репозитория и объединяет их с текущей веткой.
```
git pull
```
2.  Извлекает изменения из удаленного репозитория и повторно применяет ваши коммиты поверх изменений из удаленного репозитория. Это позволяет создать более линейную историю коммитов.
```
git pull --rebase
```
3. Извлекает изменения из указанной ветки удаленного репозитория и объединяет их с текущей веткой.
```
git pull <remote> <branch>
```
4. Извлекает изменения из удаленного репозитория и объединяет их с текущей веткой, но не создает новый коммит. Этот флаг может быть полезен, если вы хотите изменить сообщение коммита перед его созданием.
```
git pull --no-commit
```
>О git merge и git rebase вы познокомитесь в Wiki статье нашего проекта [**Git Rebase**](https://gitlab.com/levotarayan98/phobos/-/wikis/Git-Rebase)

# Прочии команды для Git

## git cherry-pick


git cherry-pick - это команда Git, которая позволяет выбрать один или несколько коммитов из одной ветки и применить их в другую ветку. Эта команда создает новый коммит в текущей ветке, который содержит те же изменения, что и выбранный коммит.

Команда git cherry-pick может быть полезна, когда вам нужно применить некоторые изменения из одной ветки в другую, не объединяя ветки. Например, вы можете использовать git cherry-pick для применения исправления ошибки из отдельной ветки в свою рабочую ветку.

Пример использования команды git cherry-pick:

1. Перейдите в ту ветку, в которую вы хотите применить изменения:

```
git checkout <target-branch>
```
2. Выполните команду git cherry-pick и укажите хэш коммита, который вы хотите применить:
```
git cherry-pick <commit-hash>
```
Если вы хотите применить несколько коммитов, укажите их хэши через пробел:
```
git cherry-pick <commit-hash-1> <commit-hash-2> <commit-hash-3>
```
3. Git создаст новый коммит, содержащий те же изменения, что и выбранный коммит, и добавит его в текущую ветку.

Кроме того, команда git cherry-pick позволяет использовать несколько флагов и параметров для управления процессом применения изменений. Например, флаг --no-commit позволяет применить изменения без создания нового коммита, а флаг --edit открывает редактор сообщения коммита для редактирования его содержимого.

## git reflog 

git reflog - это команда Git, которая показывает список всех изменений, которые были выполнены в локальном репозитории, включая коммиты, изменения веток, перемещения по истории коммитов и т. д.

Команда git reflog может быть полезна, если вы потеряли ссылку на коммит или ветку, которую хотели использовать, или если вы случайно удалили какие-то изменения в репозитории.

Пример использования команды git reflog:

```
git reflog
```
Эта команда покажет список всех действий, произведенных в локальном репозитории. В результате вы получите список с хэшами коммитов, датами, авторами и комментариями к коммитам. Если вы знаете хэш коммита, который потеряли, вы можете использовать эту команду, чтобы найти его в истории изменений.

Например, чтобы вернуться к коммиту, который был случайно удален, вы можете выполнить следующие команды:

```
git reflog
git checkout <commit-hash>
```
Команда git reflog также поддерживает ряд флагов, которые позволяют управлять выводом информации. Например, флаг --date=iso отображает даты в формате ISO, а флаг --grep=<pattern> позволяет фильтровать вывод по шаблону.
